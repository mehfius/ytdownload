const ytdl = require('ytdl-core');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');
const http = require('http');
const NodeID3 = require('node-id3');
const ffmpeg = require('fluent-ffmpeg');


const server = http.createServer(async (req, res) => {
  // Adicionar cabeçalhos CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  // Lidar com requisições OPTIONS (pré-voo)
  if (req.method === 'OPTIONS') {
    res.writeHead(204);
    return res.end();
  }

  if (req.url === '/download' && req.method === 'POST') {
    try {
      let body = '';
      req.on('data', chunk => {
        body += chunk.toString();
      });

      req.on('end', async () => {
        const { video_id, user_id, item_id } = JSON.parse(body);
        
        if (!video_id || !user_id || !item_id) {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          return res.end(JSON.stringify({ 
            error: 'Os parâmetros video_id, user_id e item_id são obrigatórios' 
          }));
        }

        // Verificar se o video_id é válido
        if (!ytdl.validateID(video_id)) {
          res.writeHead(400, { 'Content-Type': 'application/json' });
          return res.end(JSON.stringify({ error: 'ID do vídeo inválido' }));
        }

        console.log(`Usuário ${user_id} está baixando o item ${item_id}`);

        // Verificar se o vídeo existe
        const info = await ytdl.getInfo(video_id).catch(err => {
          if (err.message.includes('Video unavailable')) {
            throw new Error('Vídeo não encontrado no YouTube');
          }
          throw err;
        });

        // Calcular tamanho estimado do MP3
        const duration = parseInt(info.videoDetails.lengthSeconds);
        const bitrate = 128; // 128 kbps (bitrate comum para MP3)
        const size_in_mb = ((bitrate * duration) / 8) / 1024; // Tamanho em MB
        
        if (size_in_mb > 40) { // Limite de 40MB
          res.writeHead(413, { 'Content-Type': 'application/json' });
          return res.end(JSON.stringify({ 
            error: 'Arquivo muito grande',
            size: `${size_in_mb.toFixed(2)} MB`,
            max_size: '40 MB'
          }));
        }

        console.log(`Tamanho estimado do MP3: ${size_in_mb.toFixed(2)} MB`);

        // Inicializar video_title após obter as informações do vídeo
        const video_title = info.videoDetails.title;
        console.log(`Título do vídeo: ${video_title}`);

        // Criar JSON com nomes de propriedades mais curtos
        const file_info = {
          t: video_title,       // "t" para title
          a: info.videoDetails.author.name, // "a" para artist
          s: size_in_mb.toFixed(2) // "s" para size_in_mb
        };

        // Codificar o JSON em Base64 para o nome do arquivo
        const encoded_json = Buffer.from(JSON.stringify(file_info)).toString('base64');
        const file_name = `${encoded_json}.mp3`;

        const stream = ytdl(video_id, {
          filter: 'audioonly',
          quality: 'highestaudio',
          format: 'mp3',
        });

        stream.on('error', (error) => {
          console.error('Erro ao baixar o vídeo:', error);
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Erro ao baixar o vídeo' }));
        });

        const token = ''; // Substitua pelo seu token

        stream.pipe(fs.createWriteStream(file_name))
          .on('finish', async () => {
            try {
              const file_data = fs.readFileSync(file_name);
              
              // Fazer upload para o Supabase Storage
              const upload_url = `https://kgwnnqbpohhldfroogmm.supabase.co/storage/v1/object/mp3/${user_id}/${item_id}/${file_name}`;
              
              const response = await fetch(upload_url, {
                method: 'POST',
                headers: {
                  'Content-Type': 'audio/mpeg',
                  'Authorization': `Bearer ${token}`
                },
                body: file_data
              });

              if (!response.ok) {
                throw new Error(`Erro no upload: ${response.statusText}`);
              }

              // Analisar o arquivo para obter o bitrate
              ffmpeg.ffprobe(file_name, (err, metadata) => {
                if (err) {
                  console.error('Erro ao analisar o arquivo:', err);
                } else {
                  const bitrate = metadata.format.bit_rate;
                  console.log(`Bitrate do arquivo: ${bitrate} bps`);
                }
              });

              // Imprimir JSON
              console.log(JSON.stringify(file_info, null, 2));
            } catch (upload_error) {
              console.error('Erro ao fazer upload do arquivo:', upload_error);
            }
            
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ 
              message: 'Download concluído com sucesso',
              file_name: file_name,
              user_id: user_id,
              item_id: item_id
            }));
          })
          .on('error', (error) => {
            console.error('Erro ao salvar o arquivo:', error);
            res.writeHead(500, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Erro ao salvar o arquivo' }));
          });
      });
    } catch (error) {
      console.error('Erro no servidor:', error);
      res.writeHead(500, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Erro interno do servidor' }));
    }
  } else {
    res.writeHead(404, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Rota não encontrada' }));
  }
});

const PORT = process.env.PORT || 3003;
server.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});